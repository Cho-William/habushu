package org.bitbucket.cpointe.habushu;

import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.assembly.mojos.AbstractAssemblyMojo;
import org.apache.maven.project.MavenProject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Archives content in the staging directory into a zip file that is treated as the archive file for subsequent
 * lifecycle steps (install, deploy).
 */
@Mojo(name = "zip", defaultPhase = LifecyclePhase.PACKAGE, threadSafe = true)
public class ZipMojo extends AbstractAssemblyMojo {
    private static final Logger logger = LoggerFactory.getLogger(ZipMojo.class);


    /**
     * Reference to the Maven project.
     */
    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    private MavenProject project;
    
    /**
     * Override to make the naming of zips like a normal artifact in Maven.
     */
    @Parameter(property = "assembly.appendAssemblyId", defaultValue = "false")
    boolean appendAssemblyId;

    /**
     * Folder in which python source files are located.
     */
    @Parameter(property = "pythonSourceDirectory", required = true, defaultValue = "${project.basedir}/src/main/python")
    protected File pythonSourceDirectory;

    /**
     * The name of the python package.  Defaults to artifactId.
     */
    @Parameter(property = "packageName", required = true, defaultValue = "${project.artifactId}")
    private String packageName;

    /**
     * {@inheritDoc}
     */
    @Override
    public MavenProject getProject() {
        return project;
    }

    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        checkRequiredPackageFilesAndCreateIfNotAvailable(pythonSourceDirectory);
        super.execute();
    }

    /**
     * Checks for the existence of LICENSE, README.md and setup.py.  If they do not exist then default files are generated.
     * @param packagePath
     * @throws IOException
     */
    private void checkRequiredPackageFilesAndCreateIfNotAvailable(File packagePath) throws MojoFailureException {
        boolean licenseExists = new File(packagePath, "LICENSE").exists();
        boolean readmeExists = new File(packagePath, "README.md").exists();
        boolean setupExists = new File(packagePath, "setup.py").exists();

        try {
            if(!licenseExists) {
                logger.warn("LICENSE file not found.  Creating empty file for packaging.");
                createFileFromFileNameAndContent(packagePath, "LICENSE", "");
            }

            if(!readmeExists) {
                logger.warn("README.md file not found.  Creating empty file for packaging.");
                createFileFromFileNameAndContent(packagePath, "README.md", "");
            }
            if(!setupExists) {
                logger.warn("setup.py file not found. Creating new default setup.py");
                createSetupFile(packagePath);
            }
        } catch(IOException e) {
            logger.error("Error while creating package setup files: " + e.getMessage());
            throw new MojoFailureException("Error creating package setup files");
        }
    }

    /**
     * Creates a file and adds the provided content to the file.
     * @param packagePath
     * @param fileName
     * @param content
     * @throws IOException
     */
    private void createFileFromFileNameAndContent(File packagePath, String fileName, String content) throws IOException {
        BufferedWriter bw = null;
        try{
            File file = new File(packagePath, fileName);
            file.createNewFile();
            FileWriter fw = new FileWriter(file.getAbsoluteFile());
            bw = new BufferedWriter(fw);
            bw.write(content);
        } catch (IOException e) {
            logger.error("Couldn't create package files. " + e.getMessage());
        } finally {
            if(bw != null){
                bw.close();
            }
        }
    }

    /**
     * Creates a default setup.py file used for installing the Python package.
     * @param packagePath
     * @throws IOException
     */
    private void createSetupFile(File packagePath) throws IOException {
        String content = "import setuptools\n\n" +
                "with open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n" +
                "    long_description = fh.read()\n\n" +
                "setuptools.setup(\n" +
                "    name=\"" + packageName + "\",\n" +
                "    version=\"0.0.1\",\n" +
                "    description=\"Package generated by Habushu\",\n" +
                "    long_description=long_description,\n" +
                "    long_description_content_type=\"text/markdown\",\n" +
                "    packages=setuptools.find_packages(),\n" +
                "    zip_safe= True,\n" +
                "    classifiers=[\n" +
                "        \"Programming Language :: Python :: 3\",\n" +
                "        \"License :: OSI Approved :: MIT License\",\n" +
                "        \"Operating System :: OS Independent\",\n" +
                "    ],\n" +
                "    python_requires='>=3.7',\n" +
                ")";
        createFileFromFileNameAndContent(packagePath, "setup.py", content);
    }

    /**
     * In not overriden in the pom, pull a default assembly file from this plugin that will inform the
     * maven-assembly-plugin how to create the desired habushu zip file.
     * 
     * {@inheritDoc}
     */
    @Override
    public String[] getDescriptorReferences() {
        String[] descriptorRefs = super.getDescriptorReferences();
        if (descriptorRefs == null || descriptorRefs.length == 0) {
            String[] defaultDescriptor = { "habushu-assembly" };
            descriptorRefs = defaultDescriptor;
        }
        return descriptorRefs;
    }
}
